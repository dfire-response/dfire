#!/bin/bash
# =============================================================================
# DFIRe Installation Wizard
# =============================================================================
# Interactive installer for DFIRe production deployment.
# Works on any Linux distribution with Docker installed.
#
# Prerequisites:
#   - Docker Engine with Compose plugin
#   - openssl (for generating secrets)
#
# Usage: ./install.sh
#
# This script will:
#   1. Verify Docker is installed and running
#   2. Configure database connection (external or internal)
#   3. Generate secure secrets
#   4. Create .env configuration file
#   5. Pull and start DFIRe services
# =============================================================================

set -euo pipefail

# =============================================================================
# Configuration
# =============================================================================
# Use current directory as install location
INSTALL_DIR="${DFIRE_INSTALL_DIR:-$(pwd)}"
ENV_FILE="${INSTALL_DIR}/.env"
COMPOSE_FILE="${INSTALL_DIR}/docker-compose.prod.yml"
EXTERNAL_DB_COMPOSE="${INSTALL_DIR}/docker-compose.external-db.yml"

# =============================================================================
# Embedded Docker Compose Files
# =============================================================================
create_compose_files() {
    section "Creating Docker Compose Files"

    # Create docker-compose.prod.yml
    cat > "$COMPOSE_FILE" << 'COMPOSE_EOF'
# =============================================================================
# DFire Production Docker Compose
# Generated by install.sh
# =============================================================================

services:
  # ===========================================================================
  # PostgreSQL Database (disabled when using external DB)
  # ===========================================================================
  db:
    image: postgres:16-alpine
    container_name: dfire_db_prod
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-dfire}
      POSTGRES_USER: ${POSTGRES_USER:-dfire}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:?POSTGRES_PASSWORD is required}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-dfire} -d ${POSTGRES_DB:-dfire}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - dfire_internal

  # ===========================================================================
  # Redis (Channels + Cache)
  # ===========================================================================
  redis:
    image: redis:7-alpine
    container_name: dfire_redis_prod
    command: >
      redis-server
      --appendonly yes
      ${REDIS_PASSWORD:+--requirepass ${REDIS_PASSWORD}}
    volumes:
      - redis_data:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped
    networks:
      - dfire_internal

  # ===========================================================================
  # Django Backend (Production)
  # ===========================================================================
  backend:
    image: ${DFIRE_BACKEND_IMAGE:-dfireadmin/dfire-backend:latest}
    container_name: dfire_backend_prod
    volumes:
      - media_data:/app/media
      - static_data:/app/staticfiles
    environment:
      - DEBUG=false
      - SECRET_KEY=${SECRET_KEY:?SECRET_KEY is required}
      - DATABASE_URL=postgres://${POSTGRES_USER:-dfire}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-dfire}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:?ALLOWED_HOSTS is required}
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:?CORS_ALLOWED_ORIGINS is required}
      - CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS:-}
      - TRUST_PROXY_HEADERS=true
      - DFIRE_ENVIRONMENT=${DFIRE_ENVIRONMENT:-production}
      - CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY:?CREDENTIAL_ENCRYPTION_KEY is required}
      - AUTH_COOKIE_SECURE=${AUTH_COOKIE_SECURE:-True}
      - DJANGO_SUPERUSER_EMAIL=${DJANGO_SUPERUSER_EMAIL:-}
      - DJANGO_SUPERUSER_PASSWORD=${DJANGO_SUPERUSER_PASSWORD:-}
      - DJANGO_SUPERUSER_USERNAME=${DJANGO_SUPERUSER_USERNAME:-}
    depends_on:
      db:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    restart: unless-stopped
    networks:
      - dfire_internal
      - dfire_external

  # ===========================================================================
  # Django-Q2 Worker (Background Tasks)
  # ===========================================================================
  qcluster:
    image: ${DFIRE_BACKEND_IMAGE:-dfireadmin/dfire-backend:latest}
    container_name: dfire_qcluster_prod
    command: python manage.py qcluster
    volumes:
      - media_data:/app/media
    environment:
      - DEBUG=false
      - SECRET_KEY=${SECRET_KEY}
      - DATABASE_URL=postgres://${POSTGRES_USER:-dfire}:${POSTGRES_PASSWORD}@db:5432/${POSTGRES_DB:-dfire}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}
      - DFIRE_ENVIRONMENT=${DFIRE_ENVIRONMENT:-production}
      - CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY}
    depends_on:
      backend:
        condition: service_healthy
    restart: unless-stopped
    networks:
      - dfire_internal
      - dfire_external

  # ===========================================================================
  # Frontend + Nginx Reverse Proxy (Production)
  # ===========================================================================
  frontend:
    image: ${DFIRE_FRONTEND_IMAGE:-dfireadmin/dfire-frontend:latest}
    container_name: dfire_frontend_prod
    ports:
      - "FRONTEND_BIND_PLACEHOLDER"
    volumes:
      - static_data:/app/staticfiles:ro
    depends_on:
      - backend
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 3s
      retries: 3
    restart: unless-stopped
    networks:
      - dfire_internal
      - dfire_external

volumes:
  postgres_data:
  redis_data:
  media_data:
  static_data:

networks:
  dfire_internal:
    driver: bridge
    internal: true
  dfire_external:
    driver: bridge
COMPOSE_EOF

    # Replace placeholder with actual port binding
    sed -i "s|FRONTEND_BIND_PLACEHOLDER|${FRONTEND_BIND}|g" "$COMPOSE_FILE"

    success "Created docker-compose.prod.yml"

    # Create docker-compose.external-db.yml
    cat > "$EXTERNAL_DB_COMPOSE" << 'COMPOSE_EOF'
# =============================================================================
# DFIRe External Database Overlay
# Generated by install.sh
# =============================================================================

services:
  # Disable internal PostgreSQL
  db:
    deploy:
      replicas: 0

  # Override backend for external DATABASE_URL
  backend:
    networks:
      - dfire_internal
      - dfire_external
    environment:
      - DEBUG=false
      - SECRET_KEY=${SECRET_KEY:?SECRET_KEY is required}
      - DATABASE_URL=${DATABASE_URL:?DATABASE_URL is required for external database mode}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}
      - ALLOWED_HOSTS=${ALLOWED_HOSTS:?ALLOWED_HOSTS is required}
      - CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS:?CORS_ALLOWED_ORIGINS is required}
      - CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS:-}
      - TRUST_PROXY_HEADERS=true
      - DFIRE_ENVIRONMENT=${DFIRE_ENVIRONMENT:-production}
      - CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY:?CREDENTIAL_ENCRYPTION_KEY is required}
      - AUTH_COOKIE_SECURE=${AUTH_COOKIE_SECURE:-True}
      - DJANGO_SUPERUSER_EMAIL=${DJANGO_SUPERUSER_EMAIL:-}
      - DJANGO_SUPERUSER_PASSWORD=${DJANGO_SUPERUSER_PASSWORD:-}
      - DJANGO_SUPERUSER_USERNAME=${DJANGO_SUPERUSER_USERNAME:-}
    depends_on:
      redis:
        condition: service_healthy

  # Override qcluster for external DATABASE_URL
  qcluster:
    networks:
      - dfire_internal
      - dfire_external
    environment:
      - DEBUG=false
      - SECRET_KEY=${SECRET_KEY}
      - DATABASE_URL=${DATABASE_URL}
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - REDIS_PASSWORD=${REDIS_PASSWORD:-}
      - DFIRE_ENVIRONMENT=${DFIRE_ENVIRONMENT:-production}
      - CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY}
    depends_on:
      backend:
        condition: service_healthy
COMPOSE_EOF

    success "Created docker-compose.external-db.yml"
}

# =============================================================================
# Colors and Output Functions
# =============================================================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m' # No Color

info()    { echo -e "${BLUE}[INFO]${NC} $*"; }
success() { echo -e "${GREEN}[OK]${NC} $*"; }
warn()    { echo -e "${YELLOW}[WARN]${NC} $*"; }
error()   { echo -e "${RED}[ERROR]${NC} $*" >&2; }

banner() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                  DFIRe Installation Wizard                   ║"
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

section() {
    echo ""
    echo -e "${BOLD}=== $* ===${NC}"
    echo ""
}

# =============================================================================
# Validation Functions
# =============================================================================
validate_hostname() {
    local hostname="$1"
    if [[ "$hostname" =~ ^[a-zA-Z0-9][a-zA-Z0-9.-]*$ ]]; then
        return 0
    fi
    return 1
}

validate_email() {
    local email="$1"
    if [[ "$email" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
        return 0
    fi
    return 1
}

validate_password() {
    local password="$1"
    local min_length="${2:-12}"
    if [[ ${#password} -ge $min_length ]]; then
        return 0
    fi
    return 1
}

validate_port() {
    local port="$1"
    if [[ "$port" =~ ^[0-9]+$ ]] && ((port >= 1 && port <= 65535)); then
        return 0
    fi
    return 1
}

validate_username() {
    local username="$1"
    # Allow alphanumeric, underscore, hyphen, 2-30 chars
    if [[ "$username" =~ ^[a-zA-Z][a-zA-Z0-9_-]{1,29}$ ]]; then
        return 0
    fi
    return 1
}

urlencode() {
    # URL-encode a string (for use in DATABASE_URL)
    local string="$1"
    local length="${#string}"
    local encoded=""
    local c

    for ((i = 0; i < length; i++)); do
        c="${string:i:1}"
        case "$c" in
            [a-zA-Z0-9.~_-]) encoded+="$c" ;;
            *) encoded+=$(printf '%%%02X' "'$c") ;;
        esac
    done
    echo "$encoded"
}

# =============================================================================
# Port Availability Check
# =============================================================================
# Checks if a TCP port is available (not already bound by another process).
# Used to prevent conflicts with existing services before starting DFIRe.
# Returns 0 if port is available, 1 if in use.
check_port_available() {
    local port="$1"
    # Use ss (modern) or netstat (fallback) to check for listening ports
    if command -v ss &>/dev/null; then
        if ss -tuln 2>/dev/null | grep -q ":${port} "; then
            return 1  # Port is in use
        fi
    elif command -v netstat &>/dev/null; then
        if netstat -tuln 2>/dev/null | grep -q ":${port} "; then
            return 1  # Port is in use
        fi
    fi
    return 0  # Port is available (or couldn't check)
}

# =============================================================================
# Existing Installation Detection
# =============================================================================
# Checks for evidence of a previous DFIRe installation and offers options
# to handle it (reuse, reset, or abort). This prevents conflicts and data
# loss from accidental reinstalls.
check_existing_installation() {
    local has_env=false
    local has_containers=false
    local has_volumes=false

    # Check for existing .env file
    if [[ -f "$ENV_FILE" ]]; then
        has_env=true
    fi

    # Check for existing DFIRe containers (running or stopped)
    if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^dfire_"; then
        has_containers=true
    fi

    # Check for existing DFIRe volumes
    if docker volume ls --format '{{.Name}}' 2>/dev/null | grep -qE "^(dfire_|.*_postgres_data|.*_redis_data|.*_media_data|.*_static_data)"; then
        has_volumes=true
    fi

    # If any existing installation found, prompt user
    if [[ "$has_env" == "true" || "$has_containers" == "true" || "$has_volumes" == "true" ]]; then
        section "Existing Installation Detected"

        echo "Found evidence of a previous DFIRe installation:"
        [[ "$has_env" == "true" ]] && echo "  - Configuration file (.env)"
        [[ "$has_containers" == "true" ]] && echo "  - Docker containers"
        [[ "$has_volumes" == "true" ]] && echo "  - Docker volumes (may contain data)"
        echo ""
        echo "How would you like to proceed?"
        echo ""
        echo "  1. UPGRADE/RECONFIGURE"
        echo "     - Keep existing data volumes (database, media)"
        echo "     - Recreate configuration and containers"
        echo "     - Recommended for upgrading or fixing a broken install"
        echo ""
        echo "  2. FRESH INSTALL (removes all data)"
        echo "     - Remove ALL existing containers and volumes"
        echo "     - WARNING: This will DELETE all DFIRe data!"
        echo ""
        echo "  3. ABORT"
        echo "     - Exit without making changes"
        echo ""

        while true; do
            read -p "Select option [1]: " reinstall_choice
            reinstall_choice=${reinstall_choice:-1}

            case "$reinstall_choice" in
                1)
                    info "Keeping existing data, will recreate configuration"
                    # Stop existing containers but keep volumes
                    if [[ "$has_containers" == "true" ]]; then
                        info "Stopping existing containers..."
                        docker stop $(docker ps -a --format '{{.Names}}' | grep "^dfire_") 2>/dev/null || true
                        docker rm $(docker ps -a --format '{{.Names}}' | grep "^dfire_") 2>/dev/null || true
                        success "Existing containers removed"
                    fi
                    break
                    ;;
                2)
                    echo ""
                    warn "This will DELETE ALL DFIRe data including the database!"
                    read -p "Type 'DELETE ALL DATA' to confirm: " confirm_delete
                    if [[ "$confirm_delete" == "DELETE ALL DATA" ]]; then
                        info "Removing all DFIRe components..."
                        # Stop and remove containers
                        docker stop $(docker ps -a --format '{{.Names}}' | grep "^dfire_") 2>/dev/null || true
                        docker rm $(docker ps -a --format '{{.Names}}' | grep "^dfire_") 2>/dev/null || true
                        # Remove volumes
                        docker volume rm $(docker volume ls --format '{{.Name}}' | grep -E "^(dfire_|.*_postgres_data$|.*_redis_data$|.*_media_data$|.*_static_data$)") 2>/dev/null || true
                        # Remove old env file
                        if [[ -f "$ENV_FILE" ]]; then
                            rm -f "$ENV_FILE"
                        fi
                        success "Previous installation removed"
                        break
                    else
                        warn "Confirmation not received. Please try again."
                    fi
                    ;;
                3)
                    info "Installation aborted."
                    exit 0
                    ;;
                *)
                    warn "Invalid option. Please enter 1, 2, or 3."
                    ;;
            esac
        done
    fi
}

# =============================================================================
# Secret Generation Functions
# =============================================================================
# These functions generate cryptographically secure random values for:
# - Django SECRET_KEY: Session signing, CSRF tokens, password reset tokens
# - Fernet key: Symmetric encryption of sensitive data (credentials)
# - Passwords: Database and Redis authentication
generate_secret_key() {
    # Generate Django SECRET_KEY (50 chars, alphanumeric)
    openssl rand -base64 50 | tr -d '\n/+=' | head -c 50
}

generate_fernet_key() {
    # Generate Fernet encryption key (32 bytes, base64url encoded)
    openssl rand 32 | base64 | tr '+/' '-_'
}

generate_password() {
    # Generate random password (32 chars)
    openssl rand -base64 32 | tr -d '/+=' | head -c 32
}

# =============================================================================
# Prerequisite Checks
# =============================================================================
# Verifies all required dependencies are available before starting.
# Checks for:
#   - openssl: Required for generating cryptographic secrets
#   - docker: Container runtime for all DFIRe services
#   - docker compose: Container orchestration
#   - docker daemon: Must be running and accessible by current user
#   - port 8080: Must be available for DFIRe frontend
#
# COMMON ISSUES:
#   - "Cannot connect to Docker daemon": User not in docker group, or
#     daemon not running. Fix: sudo usermod -aG docker $USER
#   - "Port 8080 in use": Another service using the port. Stop it first.
check_prerequisites() {
    section "Checking Prerequisites"

    # Check for openssl (needed for secret generation)
    if ! command -v openssl &>/dev/null; then
        error "openssl is not installed."
        echo ""
        echo "Please install openssl first:"
        echo "  Ubuntu/Debian: sudo apt install openssl"
        echo "  RHEL/Fedora:   sudo dnf install openssl"
        echo "  macOS:         brew install openssl"
        echo ""
        exit 1
    fi
    success "openssl is available"

    # Check for Docker
    if ! command -v docker &>/dev/null; then
        error "Docker is not installed."
        echo ""
        echo "Please install Docker first:"
        echo "  https://docs.docker.com/engine/install/"
        echo ""
        echo "Quick install for common distributions:"
        echo "  Ubuntu/Debian: https://docs.docker.com/engine/install/ubuntu/"
        echo "  RHEL/Fedora:   https://docs.docker.com/engine/install/rhel/"
        echo "  macOS:         https://docs.docker.com/desktop/install/mac-install/"
        echo ""
        exit 1
    fi
    success "Docker is installed: $(docker --version | head -1)"

    # Check for Docker Compose plugin
    if ! docker compose version &>/dev/null; then
        error "Docker Compose plugin is not available."
        echo ""
        echo "Please install the Docker Compose plugin:"
        echo "  https://docs.docker.com/compose/install/"
        echo ""
        exit 1
    fi
    success "Docker Compose is available: $(docker compose version --short)"

    # Check if Docker daemon is running and accessible
    if ! docker info &>/dev/null; then
        error "Cannot connect to Docker daemon."
        echo ""
        echo "Possible causes:"
        echo "  1. Docker daemon is not running"
        echo "     Try: sudo systemctl start docker"
        echo ""
        echo "  2. Current user lacks permission to access Docker"
        echo "     Try: sudo usermod -aG docker \$USER && newgrp docker"
        echo "     Or run this script with sudo"
        echo ""
        exit 1
    fi
    success "Docker daemon is running"

    # Check if port 8080 is available (DFIRe frontend)
    if ! check_port_available 8080; then
        error "Port 8080 is already in use."
        echo ""
        echo "DFIRe needs port 8080 for the web interface."
        echo "Please stop any service using this port, or use a different machine."
        echo ""
        echo "To find what's using port 8080:"
        echo "  sudo ss -tulnp | grep :8080"
        echo "  sudo netstat -tulnp | grep :8080"
        echo ""
        exit 1
    fi
    success "Port 8080 is available"
}

# =============================================================================
# Database Configuration
# =============================================================================
# Collects PostgreSQL connection details. Two modes are supported:
#
# 1. External database (recommended for production):
#    - Connects to user-provided PostgreSQL server
#    - Data persists independently of DFIRe deployment
#    - Connection is tested before proceeding
#    - Credentials are URL-encoded to handle special characters
#
# 2. Internal database (testing only):
#    - PostgreSQL runs inside Docker container
#    - WARNING: Data is lost if Docker volumes are removed!
#    - Requires explicit "I UNDERSTAND" confirmation
#
# SECURITY: Database passwords are passed via environment variables in
# Docker Compose, never exposed on command line. External DB credentials
# are URL-encoded in DATABASE_URL to handle special characters safely.
collect_database_config() {
    section "Database Configuration"

    echo "DFIRe requires a PostgreSQL 16+ database."
    echo ""
    echo "  1. External PostgreSQL server (RECOMMENDED)"
    echo "     - You provide connection details to an existing PostgreSQL server"
    echo "     - Best for production: data persists independently of this VM"
    echo ""
    echo "  2. Internal PostgreSQL (TESTING/EVALUATION ONLY)"
    echo "     - PostgreSQL runs inside Docker on this VM"
    echo "     - WARNING: Data will be LOST if this VM is destroyed!"
    echo ""

    while true; do
        read -p "Select database option [1]: " db_choice
        db_choice=${db_choice:-1}

        case "$db_choice" in
            1)
                USE_EXTERNAL_DB=true
                collect_external_db_details
                break
                ;;
            2)
                USE_EXTERNAL_DB=false
                echo ""
                warn "WARNING: Internal database is for TESTING/EVALUATION ONLY."
                warn "All data will be LOST if this VM is destroyed!"
                echo ""
                read -p "Type 'I UNDERSTAND' to continue: " confirm
                if [[ "$confirm" == "I UNDERSTAND" ]]; then
                    info "Using internal PostgreSQL database"
                    POSTGRES_PASSWORD=$(generate_password)
                    success "Generated internal database password"
                    break
                else
                    error "Confirmation not received. Please try again."
                fi
                ;;
            *)
                warn "Invalid option. Please enter 1 or 2."
                ;;
        esac
    done
}

collect_external_db_details() {
    echo ""
    echo "Enter your PostgreSQL server details:"
    echo ""

    # PostgreSQL host
    while true; do
        read -p "PostgreSQL host: " PG_HOST
        if [[ -n "$PG_HOST" ]]; then
            break
        fi
        warn "Host cannot be empty."
    done

    # PostgreSQL port
    while true; do
        read -p "PostgreSQL port [5432]: " PG_PORT
        PG_PORT=${PG_PORT:-5432}
        if validate_port "$PG_PORT"; then
            break
        fi
        warn "Invalid port number."
    done

    # Database name
    while true; do
        read -p "Database name: " PG_DATABASE
        if [[ -n "$PG_DATABASE" ]]; then
            break
        fi
        warn "Database name cannot be empty."
    done

    # Username
    while true; do
        read -p "Username: " PG_USER
        if [[ -n "$PG_USER" ]]; then
            break
        fi
        warn "Username cannot be empty."
    done

    # Password (visible for verification)
    while true; do
        read -p "Password: " PG_PASSWORD
        if [[ -n "$PG_PASSWORD" ]]; then
            break
        fi
        warn "Password cannot be empty."
    done

    # URL-encode user and password for DATABASE_URL (handles special characters)
    local encoded_user encoded_password
    encoded_user=$(urlencode "$PG_USER")
    encoded_password=$(urlencode "$PG_PASSWORD")

    # Construct DATABASE_URL with encoded credentials
    DATABASE_URL="postgres://${encoded_user}:${encoded_password}@${PG_HOST}:${PG_PORT}/${PG_DATABASE}"

    # Test connection (pass URL via environment variable to avoid process list exposure)
    echo ""
    info "Testing database connection..."
    if docker run --rm --network host -e DATABASE_URL="$DATABASE_URL" postgres:16-alpine \
        sh -c 'psql "$DATABASE_URL" -c "SELECT 1"' > /dev/null 2>&1; then
        success "Database connection successful!"
    else
        error "Could not connect to database. Please check your credentials."
        echo ""
        read -p "Continue anyway? (y/N): " continue_anyway
        if [[ "${continue_anyway,,}" != "y" ]]; then
            exit 1
        fi
        warn "Continuing without verified database connection"
    fi
}

# =============================================================================
# Domain Configuration
# =============================================================================
collect_domain_config() {
    section "Domain Configuration"

    if [[ "$DEPLOYMENT_MODE" == "local_test" ]]; then
        # Local testing - can be localhost or LAN IP
        echo "How will you access DFIRe?"
        echo ""
        echo "  1. From THIS machine only (localhost)"
        echo "     - Access via http://localhost:8080"
        echo ""
        echo "  2. From OTHER machines on your network"
        echo "     - Enter this server's IP address (e.g., 192.168.1.100)"
        echo "     - Access via http://<ip-address>:8080"
        echo ""

        read -p "Select access mode [1]: " access_choice
        access_choice=${access_choice:-1}

        if [[ "$access_choice" == "1" ]]; then
            HOSTNAME="localhost"
        else
            echo ""
            read -p "Enter this server's IP address or hostname: " HOSTNAME
            if ! validate_hostname "$HOSTNAME"; then
                warn "Invalid format, using localhost"
                HOSTNAME="localhost"
            fi
        fi
    else
        # Production - require a real domain
        echo "Enter the hostname/domain where DFIRe will be accessible."
        echo "(This will be used for ALLOWED_HOSTS and CORS configuration)"
        echo ""

        while true; do
            read -p "Hostname (e.g., dfire.example.com): " HOSTNAME
            if validate_hostname "$HOSTNAME"; then
                break
            fi
            warn "Invalid hostname format. Use letters, numbers, dots, and hyphens."
        done
    fi

    # PROTOCOL is set by collect_deployment_mode()
    # Derive configuration values
    # Include localhost for internal health checks between containers
    ALLOWED_HOSTS="$HOSTNAME,localhost"
    CORS_ALLOWED_ORIGINS="${PROTOCOL}://${HOSTNAME}"
    CSRF_TRUSTED_ORIGINS="${PROTOCOL}://${HOSTNAME}"

    success "Domain configured: ${PROTOCOL}://${HOSTNAME}"
}

# =============================================================================
# Deployment Mode Configuration
# =============================================================================
# Determines how DFIRe will be accessed and configures security accordingly.
#
# Mode 1: LOCAL TESTING (no HTTPS)
#   - Binds to 0.0.0.0:8080 for LAN access
#   - AUTH_COOKIE_SECURE=False allows HTTP login
#   - NOT suitable for production - session cookies not protected!
#
# Mode 2: PRODUCTION with nginx + Let's Encrypt
#   - Binds to 127.0.0.1:8080 (localhost only)
#   - nginx handles TLS termination on ports 80/443
#   - AUTH_COOKIE_SECURE=True requires HTTPS
#   - Automatic certificate renewal via certbot
#
# Mode 3: PRODUCTION with external reverse proxy
#   - Binds to 0.0.0.0:8080 for external proxy access
#   - User configures TLS on their load balancer/proxy
#   - AUTH_COOKIE_SECURE=True requires HTTPS
#   - Proxy must set X-Forwarded-Proto: https header
#
# SECURITY: AUTH_COOKIE_SECURE controls the Secure flag on session cookies.
# When True, browsers only send cookies over HTTPS, preventing session
# hijacking on unencrypted connections.
collect_deployment_mode() {
    section "Deployment Mode"

    echo "How will you be using DFIRe?"
    echo ""
    echo "  1. LOCAL TESTING (no HTTPS)"
    echo "     - For evaluation on your local machine"
    echo "     - Accessible via http://localhost:8080"
    echo "     - Secure cookies disabled (allows HTTP login)"
    echo ""
    echo "  2. PRODUCTION with nginx + Let's Encrypt (recommended)"
    echo "     - We'll set up HTTPS automatically on this server"
    echo "     - Requires a domain name pointing to this server"
    echo "     - Secure cookies enabled"
    echo ""
    echo "  3. PRODUCTION with external reverse proxy"
    echo "     - You configure HTTPS on a separate load balancer/proxy"
    echo "     - DFIRe binds to 0.0.0.0:8080 for external access"
    echo "     - Secure cookies enabled"
    echo ""

    while true; do
        read -p "Select deployment mode [1]: " deploy_choice
        deploy_choice=${deploy_choice:-1}

        case "$deploy_choice" in
            1)
                DEPLOYMENT_MODE="local_test"
                AUTH_COOKIE_SECURE="False"
                FRONTEND_BIND="0.0.0.0:8080:80"
                PROTOCOL="http"
                USE_LOCAL_PROXY=false
                success "Local testing mode - HTTP access enabled"
                break
                ;;
            2)
                DEPLOYMENT_MODE="local_proxy"
                AUTH_COOKIE_SECURE="True"
                FRONTEND_BIND="127.0.0.1:8080:80"
                PROTOCOL="https"
                USE_LOCAL_PROXY=true
                info "Will set up nginx + Let's Encrypt after DFIRe starts"
                break
                ;;
            3)
                DEPLOYMENT_MODE="external_proxy"
                AUTH_COOKIE_SECURE="True"
                FRONTEND_BIND="0.0.0.0:8080:80"
                PROTOCOL="https"
                USE_LOCAL_PROXY=false
                warn "Remember to configure your external proxy to forward to port 8080"
                warn "Set X-Forwarded-Proto header to 'https' in your proxy config"
                break
                ;;
            *)
                warn "Invalid option. Please enter 1, 2, or 3."
                ;;
        esac
    done
}

# =============================================================================
# Superuser Configuration (Required)
# =============================================================================
collect_superuser_config() {
    section "Initial Admin User"

    echo "An admin account is required to access DFIRe."
    echo ""

    CREATE_SUPERUSER=true

    # Email
    while true; do
        read -p "Admin email: " SUPERUSER_EMAIL
        if validate_email "$SUPERUSER_EMAIL"; then
            break
        fi
        warn "Invalid email format."
    done

    # Username (default to "admin")
    while true; do
        read -p "Admin username [admin]: " SUPERUSER_USERNAME
        SUPERUSER_USERNAME=${SUPERUSER_USERNAME:-admin}
        if validate_username "$SUPERUSER_USERNAME"; then
            break
        fi
        warn "Invalid username. Use 2-30 characters: letters, numbers, underscore, hyphen. Must start with a letter."
    done

    # Password (visible for verification/copying to password manager)
    echo ""
    echo "Enter a password (visible for verification - copy to your password manager)"
    while true; do
        read -p "Admin password: " SUPERUSER_PASSWORD
        if validate_password "$SUPERUSER_PASSWORD" 12; then
            break
        fi
        warn "Password must be at least 12 characters."
    done

    success "Admin user configured: $SUPERUSER_EMAIL"
}

# =============================================================================
# Secret Generation
# =============================================================================
generate_secrets() {
    section "Generating Security Keys"

    info "Generating SECRET_KEY..."
    SECRET_KEY=$(generate_secret_key)
    success "SECRET_KEY generated (${#SECRET_KEY} chars)"

    info "Generating CREDENTIAL_ENCRYPTION_KEY..."
    CREDENTIAL_ENCRYPTION_KEY=$(generate_fernet_key)
    success "CREDENTIAL_ENCRYPTION_KEY generated"

    info "Generating REDIS_PASSWORD..."
    REDIS_PASSWORD=$(generate_password)
    success "REDIS_PASSWORD generated"

    echo ""
    warn "IMPORTANT: These keys are stored in .env and cannot be recovered if lost."
    warn "The CREDENTIAL_ENCRYPTION_KEY encrypts sensitive data in the database."
    warn "Changing it after deployment will make encrypted data unreadable!"
}

# =============================================================================
# Configuration Summary
# =============================================================================
show_summary() {
    section "Configuration Summary"

    # Deployment mode
    case "$DEPLOYMENT_MODE" in
        local_test)
            echo "Mode:          Local Testing (HTTP, no HTTPS)"
            ;;
        local_proxy)
            echo "Mode:          Production (nginx + Let's Encrypt)"
            ;;
        external_proxy)
            echo "Mode:          Production (external reverse proxy)"
            ;;
    esac

    # Database
    if [[ "$USE_EXTERNAL_DB" == "true" ]]; then
        echo "Database:      External (${PG_HOST}:${PG_PORT}/${PG_DATABASE})"
    else
        echo "Database:      Internal PostgreSQL (testing only)"
    fi

    # Access URL (nginx handles 443, others use 8080 directly)
    if [[ "$DEPLOYMENT_MODE" == "local_proxy" ]]; then
        echo "URL:           ${PROTOCOL}://${HOSTNAME}"
    else
        echo "URL:           ${PROTOCOL}://${HOSTNAME}:8080"
    fi

    # Security
    if [[ "$AUTH_COOKIE_SECURE" == "True" ]]; then
        echo "Cookies:       Secure (HTTPS required)"
    else
        echo "Cookies:       Insecure (HTTP allowed - testing only!)"
    fi

    # Admin user
    if [[ "$CREATE_SUPERUSER" == "true" ]]; then
        echo "Admin User:    $SUPERUSER_EMAIL"
    fi
    echo ""
}

# =============================================================================
# Environment File Generation
# =============================================================================
# Creates the .env configuration file with all settings for DFIRe.
#
# SECURITY:
#   - File permissions set to 600 (owner read/write only)
#   - Contains sensitive secrets that must not be shared
#   - Existing .env is backed up with timestamp before overwriting
#
# IMPORTANT: The CREDENTIAL_ENCRYPTION_KEY encrypts sensitive data in the
# database (API tokens, credentials). Changing this key after deployment
# will make all encrypted data unreadable!
generate_env_file() {
    section "Creating Configuration"

    # Backup existing .env if present
    if [[ -f "$ENV_FILE" ]]; then
        local backup_name=".env.backup.$(date +%Y%m%d_%H%M%S)"
        cp "$ENV_FILE" "${INSTALL_DIR}/${backup_name}"
        info "Existing .env backed up to $backup_name"
    fi

    # Generate .env file
    cat > "$ENV_FILE" << EOF
# =============================================================================
# DFIRe Production Configuration
# Generated by install.sh on $(date)
# =============================================================================

# -----------------------------------------------------------------------------
# Database Configuration
# -----------------------------------------------------------------------------
EOF

    if [[ "$USE_EXTERNAL_DB" == "true" ]]; then
        cat >> "$ENV_FILE" << EOF
# External PostgreSQL (recommended for production)
DATABASE_URL=${DATABASE_URL}
# These are not used with external DB but kept for reference
POSTGRES_DB=external
POSTGRES_USER=external
POSTGRES_PASSWORD=external
EOF
    else
        cat >> "$ENV_FILE" << EOF
# Internal PostgreSQL (testing/evaluation only)
POSTGRES_DB=dfire
POSTGRES_USER=dfire
POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
EOF
    fi

    cat >> "$ENV_FILE" << EOF

# -----------------------------------------------------------------------------
# Redis
# -----------------------------------------------------------------------------
REDIS_PASSWORD=${REDIS_PASSWORD}

# -----------------------------------------------------------------------------
# Django Security Keys
# WARNING: Do not change these after deployment - it will break encrypted data!
# -----------------------------------------------------------------------------
SECRET_KEY=${SECRET_KEY}
CREDENTIAL_ENCRYPTION_KEY=${CREDENTIAL_ENCRYPTION_KEY}

# -----------------------------------------------------------------------------
# Domain Configuration
# -----------------------------------------------------------------------------
ALLOWED_HOSTS=${ALLOWED_HOSTS}
CORS_ALLOWED_ORIGINS=${CORS_ALLOWED_ORIGINS}
CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}
DFIRE_ENVIRONMENT=production

# -----------------------------------------------------------------------------
# Security Settings
# -----------------------------------------------------------------------------
# Trust X-Forwarded-Proto headers from reverse proxy
TRUST_PROXY_HEADERS=false

# Secure cookies (requires HTTPS) - set to False only for local HTTP testing
AUTH_COOKIE_SECURE=${AUTH_COOKIE_SECURE}

# -----------------------------------------------------------------------------
# Database Mode Flag (used by backup script)
# -----------------------------------------------------------------------------
USE_EXTERNAL_DB=${USE_EXTERNAL_DB}

# -----------------------------------------------------------------------------
# Docker Images (from Docker Hub)
# -----------------------------------------------------------------------------
DFIRE_BACKEND_IMAGE=dfireadmin/dfire-backend:latest
DFIRE_FRONTEND_IMAGE=dfireadmin/dfire-frontend:latest
EOF

    if [[ "$CREATE_SUPERUSER" == "true" ]]; then
        cat >> "$ENV_FILE" << EOF

# -----------------------------------------------------------------------------
# Initial Superuser (created on first startup)
# -----------------------------------------------------------------------------
DJANGO_SUPERUSER_EMAIL=${SUPERUSER_EMAIL}
DJANGO_SUPERUSER_PASSWORD=${SUPERUSER_PASSWORD}
DJANGO_SUPERUSER_USERNAME=${SUPERUSER_USERNAME}
EOF
    fi

    cat >> "$ENV_FILE" << EOF

# -----------------------------------------------------------------------------
# Optional: SSO Configuration
# Configure in Django admin after deployment, or set here:
# -----------------------------------------------------------------------------
# OIDC_RP_CLIENT_ID=
# OIDC_RP_CLIENT_SECRET=

# -----------------------------------------------------------------------------
# Optional: External Integrations
# -----------------------------------------------------------------------------
# SLACK_CLIENT_ID=
# SLACK_CLIENT_SECRET=
# SLACK_SIGNING_SECRET=
# GOOGLE_GEMINI_API_KEY=

# -----------------------------------------------------------------------------
# Optional: S3-Compatible Storage
# -----------------------------------------------------------------------------
# AWS_ACCESS_KEY_ID=
# AWS_SECRET_ACCESS_KEY=
# AWS_STORAGE_BUCKET_NAME=
# AWS_S3_ENDPOINT_URL=
# AWS_S3_REGION_NAME=
EOF

    # Set secure permissions
    chmod 600 "$ENV_FILE"
    success ".env file created (chmod 600)"
}

# =============================================================================
# Start Services
# =============================================================================
# Pulls Docker images and starts all DFIRe containers.
#
# Services started:
#   - db: PostgreSQL database (unless using external DB)
#   - redis: Cache and message broker
#   - backend: Django API server
#   - qcluster: Django-Q2 background task worker
#   - frontend: nginx serving React app + proxying to backend
#
# Health checking:
#   - Waits up to 2.5 minutes for backend to become healthy
#   - Backend health is critical - it runs migrations on startup
#   - If not healthy in time, shows warning but doesn't fail
#
# IMAGES: By default pulls from Docker Hub (dfireadmin/dfire-*:latest)
# Can be overridden via DFIRE_BACKEND_IMAGE and DFIRE_FRONTEND_IMAGE in .env
start_services() {
    section "Starting Services"

    cd "$INSTALL_DIR"

    local compose_cmd="docker compose -f docker-compose.prod.yml"

    if [[ "$USE_EXTERNAL_DB" == "true" ]]; then
        compose_cmd+=" -f docker-compose.external-db.yml"
    fi

    info "Pulling container images..."
    if $compose_cmd pull; then
        success "Container images pulled"
    else
        error "Failed to pull container images"
        exit 1
    fi

    info "Starting services..."
    if $compose_cmd up -d; then
        success "Services started"
    else
        error "Failed to start services"
        exit 1
    fi

    # Wait for services to be healthy
    info "Waiting for services to be ready..."
    local max_attempts=30
    local attempt=1

    while [[ $attempt -le $max_attempts ]]; do
        # Check if backend is healthy
        if docker inspect --format='{{.State.Health.Status}}' dfire_backend_prod 2>/dev/null | grep -q "healthy"; then
            success "Backend is healthy"
            break
        fi

        if [[ $attempt -eq $max_attempts ]]; then
            warn "Services did not become healthy within expected time."
            warn "Check logs with: $compose_cmd logs"
            break
        fi

        echo -n "."
        sleep 5
        ((attempt++))
    done
    echo ""

    # Show status
    echo ""
    $compose_cmd ps
}

# =============================================================================
# Completion Message
# =============================================================================
show_completion() {
    echo ""
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════╗"
    echo "║                   Installation Complete!                     ║"
    echo "╠══════════════════════════════════════════════════════════════╣"

    case "$DEPLOYMENT_MODE" in
        local_test)
            echo "║  DFIRe is running in LOCAL TESTING mode                      ║"
            echo "║                                                              ║"
            printf "║  Access DFIRe at: %-42s ║\n" "http://${HOSTNAME}:8080"
            echo "║                                                              ║"
            echo "║  NOTE: Secure cookies are DISABLED for HTTP access.          ║"
            echo "║  Do NOT use this configuration in production!                ║"
            ;;
        local_proxy)
            echo "║  DFIRe is running on port 8080 (localhost only)              ║"
            echo "║                                                              ║"
            echo "║  HTTPS setup will begin next...                              ║"
            ;;
        external_proxy)
            echo "║  DFIRe is running on port 8080 (all interfaces)              ║"
            echo "║                                                              ║"
            echo "║  Configure your reverse proxy to forward HTTPS to:           ║"
            printf "║    http://<this-server>:8080%-32s ║\n" ""
            echo "║                                                              ║"
            echo "║  Required proxy headers:                                     ║"
            echo "║    X-Forwarded-Proto: https                                  ║"
            echo "║    X-Forwarded-For: <client-ip>                              ║"
            ;;
    esac

    if [[ "$CREATE_SUPERUSER" == "true" ]]; then
        echo "║                                                              ║"
        echo "║  Admin credentials (change on first login):                  ║"
        printf "║    Username: %-47s ║\n" "$SUPERUSER_USERNAME"
        printf "║    Password: %-47s ║\n" "$SUPERUSER_PASSWORD"
    fi
    echo "╚══════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo ""
    echo "Useful Commands:"
    echo "  Installation directory: ${INSTALL_DIR}"
    echo ""
    if [[ "$USE_EXTERNAL_DB" == "true" ]]; then
        echo "  View logs:     cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml -f docker-compose.external-db.yml logs -f"
        echo "  Stop:          cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml -f docker-compose.external-db.yml down"
        echo "  Start:         cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml -f docker-compose.external-db.yml up -d"
    else
        echo "  View logs:     cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml logs -f"
        echo "  Stop:          cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml down"
        echo "  Start:         cd ${INSTALL_DIR} && docker compose -f docker-compose.prod.yml up -d"
    fi
    echo ""
}

# =============================================================================
# HTTPS Setup (nginx + Let's Encrypt)
# =============================================================================
# Configures TLS/SSL for production deployments using Let's Encrypt.
#
# Process:
#   1. Verify root privileges (required for nginx/certbot)
#   2. Check port 80/443 availability
#   3. Check for existing certificates (offer to reuse)
#   4. Verify domain resolves to this server (warning only)
#   5. Install nginx + certbot packages
#   6. Obtain certificate via ACME HTTP-01 challenge
#   7. Configure nginx as HTTPS reverse proxy
#   8. Enable TRUST_PROXY_HEADERS in Django for X-Forwarded-Proto
#
# SECURITY NOTES:
#   - Uses TLSv1.2 and TLSv1.3 only (no legacy protocols)
#   - HSTS enabled with 2-year max-age
#   - Certificate auto-renewal via certbot systemd timer
#   - nginx runs as reverse proxy; Django never exposed directly
#
# PREREQUISITES:
#   - Domain must resolve to this server's public IP
#   - Ports 80 and 443 must be reachable from internet
#   - Firewall must allow inbound TCP 80/443
setup_https() {
    section "Setting Up HTTPS"

    # Check if running as root (required for nginx/certbot)
    if [[ $EUID -ne 0 ]]; then
        warn "HTTPS setup requires root privileges."
        echo ""
        echo "After installation completes, run:"
        echo "  sudo ${INSTALL_DIR}/setup-https.sh"
        echo ""
        echo "Or configure your own reverse proxy to forward to port 8080."
        create_https_helper_script
        return
    fi

    # Check if port 80 is available (required for certbot ACME challenge)
    # Note: We check even if nginx is installed because nginx might be stopped
    if ! check_port_available 80; then
        # Check if it's nginx that's using port 80
        if systemctl is-active nginx &>/dev/null; then
            info "nginx is running on port 80 - will be reconfigured"
        else
            error "Port 80 is already in use by another service."
            echo ""
            echo "Let's Encrypt requires port 80 for the ACME challenge."
            echo "Please stop the service using port 80 before continuing."
            echo ""
            echo "To find what's using port 80:"
            echo "  sudo ss -tulnp | grep :80"
            echo ""
            create_https_helper_script
            return
        fi
    fi

    # Check if port 443 is available (required for HTTPS)
    if ! check_port_available 443; then
        if systemctl is-active nginx &>/dev/null; then
            info "nginx is running on port 443 - will be reconfigured"
        else
            error "Port 443 is already in use by another service."
            echo ""
            echo "HTTPS requires port 443. Please stop the service using this port."
            echo ""
            create_https_helper_script
            return
        fi
    fi

    # Check for existing Let's Encrypt certificate
    if [[ -d "/etc/letsencrypt/live/${HOSTNAME}" ]]; then
        info "Existing Let's Encrypt certificate found for ${HOSTNAME}"
        echo ""
        echo "  1. USE EXISTING certificate"
        echo "  2. RENEW/REPLACE certificate"
        echo ""
        read -p "Select option [1]: " cert_choice
        cert_choice=${cert_choice:-1}

        if [[ "$cert_choice" == "1" ]]; then
            info "Using existing certificate"
            SKIP_CERTBOT=true
        else
            SKIP_CERTBOT=false
        fi
    else
        SKIP_CERTBOT=false
    fi

    # Check for existing nginx configuration
    if [[ -f "/etc/nginx/sites-available/dfire" ]] || [[ -f "/etc/nginx/conf.d/dfire.conf" ]]; then
        warn "Existing nginx configuration for DFIRe found - will be overwritten"
    fi

    # Check if domain resolves to this server
    info "Checking if ${HOSTNAME} resolves to this server..."
    local server_ip domain_ip
    server_ip=$(curl -s -4 --max-time 5 ifconfig.me 2>/dev/null || curl -s -4 --max-time 5 icanhazip.com 2>/dev/null || echo "")
    domain_ip=$(dig +short "$HOSTNAME" 2>/dev/null | head -1 || echo "")

    if [[ -n "$server_ip" && -n "$domain_ip" ]]; then
        if [[ "$domain_ip" == "$server_ip" ]]; then
            success "Domain $HOSTNAME resolves to this server ($server_ip)"
        else
            warn "Domain $HOSTNAME resolves to $domain_ip, but this server is $server_ip"
            warn "Let's Encrypt verification may fail if domain doesn't point here"
        fi
    else
        warn "Could not verify domain resolution. Make sure $HOSTNAME points to this server."
    fi

    echo ""
    echo "This will:"
    echo "  1. Install nginx and certbot"
    echo "  2. Obtain SSL certificate from Let's Encrypt"
    echo "  3. Configure nginx as HTTPS reverse proxy"
    echo ""
    read -p "Continue with HTTPS setup? [Y/n]: " https_confirm
    https_confirm=${https_confirm:-Y}

    if [[ ! "${https_confirm,,}" =~ ^y ]]; then
        info "Skipping HTTPS setup. You'll need to configure a reverse proxy manually."
        create_https_helper_script
        return
    fi

    # Get email for certificate
    while true; do
        read -p "Email for Let's Encrypt notifications: " CERT_EMAIL
        if [[ "$CERT_EMAIL" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$ ]]; then
            break
        fi
        warn "Invalid email format."
    done

    # Install packages
    info "Installing nginx and certbot..."
    if command -v apt-get &>/dev/null; then
        apt-get update && apt-get install -y nginx certbot python3-certbot-nginx
    elif command -v dnf &>/dev/null; then
        dnf install -y nginx certbot python3-certbot-nginx
    elif command -v yum &>/dev/null; then
        yum install -y nginx certbot python3-certbot-nginx
    else
        error "Could not detect package manager. Please install nginx and certbot manually."
        return
    fi
    success "Packages installed"

    # Obtain certificate (if not using existing)
    if [[ "${SKIP_CERTBOT:-false}" != "true" ]]; then
        # Stop nginx for standalone certificate acquisition
        systemctl stop nginx 2>/dev/null || true

        info "Obtaining SSL certificate..."
        if certbot certonly --standalone -d "$HOSTNAME" --email "$CERT_EMAIL" --agree-tos --non-interactive; then
            success "SSL certificate obtained!"
        else
            error "Failed to obtain SSL certificate"
            error "Make sure $HOSTNAME points to this server and port 80 is open"
            return
        fi
    else
        # Still stop nginx to reconfigure
        systemctl stop nginx 2>/dev/null || true
        success "Using existing SSL certificate"
    fi

    # Configure nginx
    info "Configuring nginx..."
    rm -f /etc/nginx/sites-enabled/default 2>/dev/null || true

    cat > /etc/nginx/sites-available/dfire << NGINX_EOF
# DFIRe HTTPS Reverse Proxy - Generated by install.sh

server {
    listen 80;
    listen [::]:80;
    server_name ${HOSTNAME};

    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    location / {
        return 301 https://\$host\$request_uri;
    }
}

server {
    listen 443 ssl;
    listen [::]:443 ssl;
    http2 on;
    server_name ${HOSTNAME};

    ssl_certificate /etc/letsencrypt/live/${HOSTNAME}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${HOSTNAME}/privkey.pem;

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;

    add_header Strict-Transport-Security "max-age=63072000" always;

    access_log /var/log/nginx/dfire_access.log;
    error_log /var/log/nginx/dfire_error.log;

    client_max_body_size 100M;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }

    location /ws/ {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_connect_timeout 7d;
        proxy_send_timeout 7d;
        proxy_read_timeout 7d;
    }
}
NGINX_EOF

    ln -sf /etc/nginx/sites-available/dfire /etc/nginx/sites-enabled/dfire 2>/dev/null || \
        ln -sf /etc/nginx/sites-available/dfire /etc/nginx/conf.d/dfire.conf

    if nginx -t; then
        success "Nginx configuration is valid"
    else
        error "Nginx configuration test failed"
        return
    fi

    # Update .env for proxy headers
    if grep -q "^TRUST_PROXY_HEADERS=false" "$ENV_FILE"; then
        sed -i "s|^TRUST_PROXY_HEADERS=false|TRUST_PROXY_HEADERS=true|g" "$ENV_FILE"
    fi

    # Restart services
    systemctl enable nginx
    systemctl start nginx

    # Restart DFIRe to pick up env changes
    cd "$INSTALL_DIR"
    local compose_cmd="docker compose -f docker-compose.prod.yml"
    if [[ "$USE_EXTERNAL_DB" == "true" ]]; then
        compose_cmd+=" -f docker-compose.external-db.yml"
    fi
    $compose_cmd up -d

    echo ""
    echo -e "${GREEN}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${GREEN}║${NC}                   HTTPS Configuration Complete!              ${GREEN}║${NC}"
    echo -e "${GREEN}╠══════════════════════════════════════════════════════════════╣${NC}"
    printf "${GREEN}║${NC}  DFIRe is now available at: %-33s${GREEN}║${NC}\n" "https://${HOSTNAME}"
    echo -e "${GREEN}║${NC}  Certificate auto-renewal is configured via certbot.         ${GREEN}║${NC}"
    echo -e "${GREEN}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

create_https_helper_script() {
    # Create a helper script that can be run later with sudo
    cat > "${INSTALL_DIR}/setup-https.sh" << 'HELPER_EOF'
#!/bin/bash
# Run this script with sudo to set up HTTPS after installation
# Usage: sudo ./setup-https.sh

set -e

INSTALL_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
ENV_FILE="${INSTALL_DIR}/.env"

if [[ $EUID -ne 0 ]]; then
    echo "This script must be run as root (use sudo)"
    exit 1
fi

if [[ ! -f "$ENV_FILE" ]]; then
    echo ".env file not found. Run install.sh first."
    exit 1
fi

# Source env to get domain
set -a
source "$ENV_FILE"
set +a

DOMAIN=$(echo "$ALLOWED_HOSTS" | cut -d',' -f1 | xargs)

echo "Setting up HTTPS for $DOMAIN"
echo ""
read -p "Email for Let's Encrypt: " CERT_EMAIL

# Install packages
if command -v apt-get &>/dev/null; then
    apt-get update && apt-get install -y nginx certbot python3-certbot-nginx
elif command -v dnf &>/dev/null; then
    dnf install -y nginx certbot python3-certbot-nginx
fi

systemctl stop nginx 2>/dev/null || true

certbot certonly --standalone -d "$DOMAIN" --email "$CERT_EMAIL" --agree-tos --non-interactive

# Create nginx config
rm -f /etc/nginx/sites-enabled/default 2>/dev/null || true

cat > /etc/nginx/sites-available/dfire << NGINX_EOF
server {
    listen 80;
    server_name ${DOMAIN};
    location /.well-known/acme-challenge/ { root /var/www/html; }
    location / { return 301 https://\$host\$request_uri; }
}
server {
    listen 443 ssl;
    http2 on;
    server_name ${DOMAIN};
    ssl_certificate /etc/letsencrypt/live/${DOMAIN}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/${DOMAIN}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    client_max_body_size 100M;
    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
NGINX_EOF

ln -sf /etc/nginx/sites-available/dfire /etc/nginx/sites-enabled/dfire 2>/dev/null || \
    ln -sf /etc/nginx/sites-available/dfire /etc/nginx/conf.d/dfire.conf

sed -i "s|^TRUST_PROXY_HEADERS=false|TRUST_PROXY_HEADERS=true|g" "$ENV_FILE"

systemctl enable nginx
systemctl start nginx

cd "$INSTALL_DIR"
COMPOSE_CMD="docker compose -f docker-compose.prod.yml"
if grep -q "^USE_EXTERNAL_DB=true" "$ENV_FILE"; then
    COMPOSE_CMD="$COMPOSE_CMD -f docker-compose.external-db.yml"
fi
$COMPOSE_CMD up -d

echo ""
echo "HTTPS is now configured! Access DFIRe at: https://${DOMAIN}"
HELPER_EOF

    chmod +x "${INSTALL_DIR}/setup-https.sh"
    info "Created ${INSTALL_DIR}/setup-https.sh for later HTTPS setup"
}

# =============================================================================
# Main
# =============================================================================
main() {
    banner
    check_prerequisites
    check_existing_installation
    collect_deployment_mode
    collect_database_config
    collect_domain_config
    collect_superuser_config
    generate_secrets
    show_summary

    read -p "Proceed with installation? [Y/n]: " proceed
    proceed=${proceed:-Y}

    if [[ "${proceed,,}" != "y" && "${proceed,,}" != "yes" ]]; then
        info "Installation cancelled."
        exit 0
    fi

    # Mark installation as started (for cleanup messaging)
    INSTALL_STARTED=true

    generate_env_file
    create_compose_files
    start_services
    show_completion

    # Set up HTTPS if using local proxy
    if [[ "$USE_LOCAL_PROXY" == "true" ]]; then
        setup_https
    fi
}

# =============================================================================
# Cleanup on Failure
# =============================================================================
# Called when the script exits due to error or interrupt.
# Provides information about partial state and how to retry.
INSTALL_STARTED=false
cleanup_on_failure() {
    local exit_code=$?
    echo ""

    if [[ "$INSTALL_STARTED" == "true" ]]; then
        warn "Installation did not complete successfully."
        echo ""
        echo "The following may have been partially created:"
        [[ -f "$ENV_FILE" ]] && echo "  - Configuration file: ${ENV_FILE}"
        [[ -f "$COMPOSE_FILE" ]] && echo "  - Docker compose file: ${COMPOSE_FILE}"
        docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "^dfire_" && echo "  - Docker containers (some may be running)"
        echo ""
        echo "To retry installation:"
        echo "  1. Run this script again - it will detect existing installation"
        echo "  2. Choose 'UPGRADE/RECONFIGURE' to fix the broken install"
        echo "  3. Or choose 'FRESH INSTALL' to start over (deletes data!)"
        echo ""
    fi

    exit "${exit_code:-1}"
}

# Handle interrupts and errors
trap 'echo ""; warn "Installation interrupted."; cleanup_on_failure' INT TERM
trap 'cleanup_on_failure' ERR

# Run main function
main "$@"
